                   ;;;;;COMPUTER MODELS OF MUSICAL CREATIVITY;;;;;                   ;;;;;            By David Cope            ;;;;;                   ;;;;;     Sorcerer Function/Chapter 5     ;;;;;                   ;;;;;             COMMON LISP             ;;;;;                   ;;;;;   interface code to run sorcerer    ;;;;;                   ;;;;;               function              ;;;;;                   ;;;;;COMPUTER MODELS OF MUSICAL CREATIVITY;;;;;(defVar *THE-CLEF* 'cmn::treble "Current clef.");;;;;#|(translate-to-alice-notation           32           '((0 55 750 1 64) (750 55 250 1 64) (1000 55 2000 1 64)            (3000 60 750 1 64) (3750 59 250 1 64) (4000 60 750 1 64)            (4750 62 250 1 64)))nil|#;;;;;(defun TRANSLATE-TO-ALICE-NOTATION (size events)  "The main notation page creator function."(setq *names* (cons *target-name* *source-items*))  (if cmn::*score-pages* (mapcar #'window-close cmn::*score-pages*))  (setf events (sortcar #'<  events))  (setf events         (sculpt-music (if *channels-choice* (evaluate-channels events) events)))  (if (and events (equal *key-signature* 'auto))(setq *key-signature* (discover-signature (remove-rests events))))  (setf events (translate-starts events))  (if events    (cmn::cmn (cmn::output-type *output-type*) (eval (list 'cmn::size size))              (apply #'cmn::system                      (cons cmn::bracket                           (loop for channel in events                                 collect                                  (eval                                   (make-a-staff channel                                                (if (seventh (first channel))                                                  (eval (seventh (first channel)))                                                  (determine-clef channel))                                                *beats*                                                 *tactus*)))))              (cmn::left-margin *left-margin*)              (cmn::AUTOMATIC-MEASURE-NUMBERS *AUTOMATIC-MEASURE-NUMBERS*)              (cmn::AUTOMATIC-RESTS *AUTOMATIC-RESTS*)              (cmn::AUTOMATIC-TIES *AUTOMATIC-TIES*)              (cmn::AUTOMATIC-BEAMS *AUTOMATIC-BEAMS*)              (cmn::REDUNDANT-ACCIDENTALS *REDUNDANT-ACCIDENTALS*)              (cmn::note-head-size *note-head-size*)              (cmn::beam-spacing *beam-spacing*)              (cmn::beam-width *beam-width*)              (cmn::DYNAMICS-SIZE *DYNAMICS-SIZE*)              (cmn::IDEAL-STEM-LENGTH *IDEAL-STEM-LENGTH*)              (cmn::STEM-WIDTH *STEM-WIDTH*)              (cmn::PAGE-WIDTH *PAGE-WIDTH*)              (cmn::PAGE-HEIGHT *PAGE-HEIGHT*)              (cmn::RIGHT-MARGIN *RIGHT-MARGIN*)              (cmn::FOOTER-MARGIN *FOOTER-MARGIN*)              (cmn::STAFF-SEPARATION *STAFF-SEPARATION*)              (cmn::layout :new-style)              (cmn::automatic-bars nil)              (cmn::STAFF-LINE-WIDTH *STAFF-LINE-WIDTH*)              (cmn::LINE-SEPARATION *LINE-SEPARATION*)              (cmn::SYSTEM-SEPARATION *system-separation*)              (cmn::staff-name-font-minimum-size 12)              (cmn::staff-name-font "times")              (cmn::full-last-line *full-last-line*)              (cmn::title *print-name*)))  (if *pages-window* (window-close *pages-window*))  (if (> (length cmn::*score-pages*) 1)    (setq *pages-window* (make-instance 'page-floating-window))));;;;;#| (translate-to-Alice-print           24           ((0 60 1000 4 127) (0 67 1000 2 127) (0 64 1000 3 127) (0 72 1000 1 127)...     #<score #x15F2E1E|#;;;;;(defun TRANSLATE-TO-ALICE-PRINT (size events)  "The main notation page creator function."  (if cmn::*score-pages* (mapcar #'window-close cmn::*score-pages*))  (setf events (sortcar #'<  events))  (setf events         (sculpt-music (if *channels-choice* (evaluate-channels events) events)))  (if (and events (equal *key-signature* 'auto))(setq *key-signature* (discover-signature (remove-rests events))))  (setf events (translate-starts events))  (if events    (cmn::cmn (cmn::output-type *output-type*) (eval (list 'cmn::size size))              (apply #'cmn::system                      (cons cmn::bracket                           (loop for channel in events                                 collect                                  (eval                                   (make-a-staff channel                                                (if (seventh (first channel))                                                  (eval (seventh (first channel)))                                                  (determine-clef channel))                                                *beats*                                                 *tactus*)))))              (cmn::left-margin *left-margin*)              (cmn::AUTOMATIC-MEASURE-NUMBERS *AUTOMATIC-MEASURE-NUMBERS*)              (cmn::AUTOMATIC-RESTS *AUTOMATIC-RESTS*)              (cmn::AUTOMATIC-TIES *AUTOMATIC-TIES*)              (cmn::AUTOMATIC-BEAMS *AUTOMATIC-BEAMS*)              (cmn::REDUNDANT-ACCIDENTALS *REDUNDANT-ACCIDENTALS*)              (cmn::note-head-size *note-head-size*)              (cmn::beam-spacing *beam-spacing*)              (cmn::beam-width *beam-width*)              (cmn::DYNAMICS-SIZE *DYNAMICS-SIZE*)              (cmn::IDEAL-STEM-LENGTH *IDEAL-STEM-LENGTH*)              (cmn::STEM-WIDTH *STEM-WIDTH*)              (cmn::PAGE-WIDTH *PAGE-WIDTH*)              (cmn::PAGE-HEIGHT *PAGE-HEIGHT*)              (cmn::RIGHT-MARGIN *RIGHT-MARGIN*)              (cmn::FOOTER-MARGIN *FOOTER-MARGIN*)              (cmn::STAFF-SEPARATION *STAFF-SEPARATION*)              (cmn::STAFF-LINE-WIDTH *STAFF-LINE-WIDTH*)              (cmn::LINE-SEPARATION *LINE-SEPARATION*)              (cmn::SYSTEM-SEPARATION *system-separation*)              (cmn::staff-name-font-minimum-size 12)              (cmn::staff-name-font "times")              (cmn::full-last-line *full-last-line*)              (cmn::output-file *print-name*)              (cmn::title *print-name*)))  (if *pages-window* (window-close *pages-window*))  (if (> (length cmn::*score-pages*) 1)    (setq *pages-window* (make-instance 'page-floating-window))));;;;;#|(make-chord '((0 55 750 1 64) (750 55 250 1 64) (1000 55 2000 1 64)                (3000 60 750 1 64) (3750 59 250 1 64)                (4000 60 750 1 64) (4750 62 250 1 64)))      nil|#;;;;;(defun MAKE-CHORD (events &optional (chord ()))  "This gets a chord but only the first chord to appear in events      and should be used before the regular call in make-a-staff."  (cond ((null events)())        ((and chord (not (equal (first (first events))                                (first (second events)))))         (list (first events)))        ((and (not (null (cdr events)))              (equal (first (first events))                     (first (second events))))         (cons (first events)               (make-chord (cdr events) t)))        (t ())));;;;;#|(create-chord-events            '((0 55 750 1 64) (750 55 250 1 64) (1000 55 2000 1 64)              (3000 60 750 1 64) (3750 59 250 1 64) (4000 60 750 1 64)              (4750 62 250 1 64)))((cmn::g3 cmn::e. (cmn::onset 0.0) cmn::mp) (cmn::g3 cmn::s (cmn::onset 0.75)) . . .|#;;;;;(defun CREATE-CHORD-EVENTS (events &optional (old-dynamic ()))  (cond ((null events)())        ((setf test (make-chord events))         (cons (list 'cmn::chord                     (remove 'cmn::rest                             (apply #'append                                     (list '(cmn::notes)                                          (loop for event in test                                                collect (translate-pitch (second event)                                                                         (sixth event))))))                     (if (cdr (nthcdr (length test) events))                       (translate-duration (ensure-chords-of-equal-duration test (nthcdr (length test) events)))                       (translate-duration (third (first test))))                     (list 'cmn::onset (float (/ (very-first events) 1000))))               (create-chord-events (nthcdr (length test) events) old-dynamic)))        (t (cons (apply #'append (list (list (setq status (translate-pitch (second (first events))                                                                           (cond ((sixth (first events)))                                                                                 (t *key-signature*)))))                                       (list (translate-duration (third (first events))))                                       (list (list 'cmn::onset (float (/ (very-first events) 1000))))                                       (let ((dynamic (get-dynamic (fifth (first events)))))                                         (if (and (not (equal status 'cmn::rest))                                                  (not (equal dynamic old-dynamic)))                                           (list (setf old-dynamic dynamic))))                                       (if (eighth (first events))(list (eighth (first events))))                                       ))                 (create-chord-events (cdr events) old-dynamic)))));;;;;#|(ensure-chords-of-equal-duration '((0 60 1000 1 127)) '((0 60 1000 1 127)))     0|#;;;;;(defun ENSURE-CHORDS-OF-EQUAL-DURATION (chord events)  "Ensures that chords have a single duration not overcutting the next event in the same channel."  (let ((longest-duration (first (my-sort #'> (loop for event in chord                                                    collect (third event)))))        (next-ontime (very-first events)))    (if (<= (+ (very-first chord) longest-duration) next-ontime)      longest-duration      (- next-ontime (very-first chord)))));;;;;#|(make-a-staff ((0 60 1000 4 127) (0 67 1000 2 127) (0 64 1000 3 127)                        (0 72 1000 1 127) (1000 55 1000 4 127) (1000 67 1000 2 127)...      (staff #<write-protected-clef #x11BE0DE>             (meter 4 4)             (c4 q (onset 0.0)|#;;;;;(defvar *names* ())(defun MAKE-A-STAFF (events &optional (clef cmn::bass)(meter *beats*)(tactus *tactus*))  "Returns data for making a staff."  (apply #'append          (list '(cmn::staff) (list clef)                (list (list 'cmn::meter meter tactus '(cmn::meter-size 0)))               (list (list 'cmn::staff-name (write-to-string (if (equal *choice-of-score-or-match* 'match) (pop *names*) *score-name*))))               (create-chord-events events))));;;;;#|(determine-clef           '((0 60 1000 4 127) (0 67 1000 2 127) (0 64 1000 3 127) (0 72 1000 1 127)             (1000 55 1000 4 127) (1000 67 1000 2 127) (1000 59 1000 3 127)...     treble|#;;;;;(defun DETERMINE-CLEF (music)  "Returns the appropriate clef for notation."  "This function returns the clef based on the range of the music."  (let* ((notes (remove-zeros (mapcar #'second music)))         (average (round (/ (apply '+ notes)(length notes)))))    (if (>= average 60) 'cmn::treble 'cmn::bass)));;;;;#|(remove-zeros '(55 55 55 60 59 60 62))    (55 55 55 60 59 60 62)|#;;;;;(defun REMOVE-ZEROS (list)  "Removes any zeros from its last arg."  (loop for n in list        if (not (zerop n))        collect n));;;;;#|(translate-pitch 55 'sharp)     cmn::g3|#;;;;;(defun TRANSLATE-PITCH (midi-pitch accidental)  "Translate pitch into object."  (if (zerop midi-pitch)    'cmn::rest    (if (equal accidental 'sharp)      (nth (- (bring-into-range midi-pitch 24 119) 24)           '(cmn::c1 cmn::cs1 cmn::d1 cmn::ds1 cmn::e1 cmn::f1 cmn::fs1 cmn::g1 cmn::gs1 cmn::a1 cmn::as1 cmn::b1              cmn::c2 cmn::cs2 cmn::d2 cmn::ds2 cmn::e2 cmn::f2 cmn::fs2 cmn::g2 cmn::gs2 cmn::a2 cmn::as2 cmn::b2              cmn::c3 cmn::cs3 cmn::d3 cmn::ds3 cmn::e3 cmn::f3 cmn::fs3 cmn::g3 cmn::gs3 cmn::a3 cmn::as3 cmn::b3             cmn::c4 cmn::cs4 cmn::d4 cmn::ds4 cmn::e4 cmn::f4 cmn::fs4 cmn::g4 cmn::gs4 cmn::a4 cmn::as4 cmn::b4             cmn::c5 cmn::cs5 cmn::d5 cmn::ds5 cmn::e5 cmn::f5 cmn::fs5 cmn::g5 cmn::gs5 cmn::a5 cmn::as5 cmn::b5             cmn::c6 cmn::cs6 cmn::d6 cmn::ds6 cmn::e6 cmn::f6 cmn::fs6 cmn::g6 cmn::gs6 cmn::a6 cmn::as6 cmn::b6             cmn::c7 cmn::cs7 cmn::d7 cmn::ds7 cmn::e7 cmn::f7 cmn::fs7 cmn::g7 cmn::gs7 cmn::a7 cmn::as7 cmn::b7             cmn::c8 cmn::cs8 cmn::d8 cmn::ds8 cmn::e8 cmn::f8 cmn::fs8 cmn::g8 cmn::gs8 cmn::a8 cmn::as8 cmn::b8))      (nth (- (bring-into-range midi-pitch 24 119) 24)           '(cmn::c1 cmn::df1 cmn::d1 cmn::ef1 cmn::e1 cmn::f1 cmn::gf1 cmn::g1 cmn::af1 cmn::a1 cmn::bf1 cmn::b1              cmn::c2 cmn::df2 cmn::d2 cmn::ef2 cmn::e2 cmn::f2 cmn::gf2 cmn::g2 cmn::af2 cmn::a2 cmn::bf2 cmn::b2              cmn::c3 cmn::df3 cmn::d3 cmn::ef3 cmn::e3 cmn::f3 cmn::gf3 cmn::g3 cmn::af3 cmn::a3 cmn::bf3 cmn::b3             cmn::c4 cmn::df4 cmn::d4 cmn::ef4 cmn::e4 cmn::f4 cmn::gf4 cmn::g4 cmn::af4 cmn::a4 cmn::bf4 cmn::b4             cmn::c5 cmn::df5 cmn::d5 cmn::ef5 cmn::e5 cmn::f5 cmn::gf5 cmn::g5 cmn::af5 cmn::a5 cmn::bf5 cmn::b5             cmn::c6 cmn::df6 cmn::d6 cmn::ef6 cmn::e6 cmn::f6 cmn::gf6 cmn::g6 cmn::af6 cmn::a6 cmn::bf6 cmn::b6             cmn::c7 cmn::df7 cmn::d7 cmn::ef7 cmn::e7 cmn::f7 cmn::gf7 cmn::g7 cmn::af7 cmn::a7 cmn::bf7 cmn::b7             cmn::c8 cmn::df8 cmn::d8 cmn::ef8 cmn::e8 cmn::f8 cmn::gf8 cmn::g8 cmn::af8 cmn::a8 cmn::bf8 cmn::b8)))))(defVar *DURATION-LIST* '(125 167 200 249 250 300 333 334 375 400 499 500 600 666 667 750 800 833 999 1000                             1200 1250 1333 1332 1334 1500 1600 1999 2000 2250 2400 2500 2667 3000 3200 3250 3999 4000 4800 6000 8000));;;;;#|(bring-into-range 55 24 119)     55|#;;;;;(defun BRING-INTO-RANGE (note low-limit high-limit)  "Brings note within the limits mod 12."  (cond ((and (> note low-limit)(< note high-limit)) note)        ((< note low-limit)(bring-into-range (+ note 12) low-limit high-limit))        ((> note high-limit)(bring-into-range (- note 12) low-limit high-limit))        (t note)));;;;;#|(translate-duration 750)     cmn::e.|#;;;;;(defun TRANSLATE-DURATION (duration)  "this version attempts to ameleorate the problem when the closest is  very far away?"  (let ((test (find-closest duration *DURATION-LIST*)))    (if (> (abs (- test duration)) 100)      (list 'cmn::rq (/ duration 1000))      (second (assoc (find-closest duration *DURATION-LIST*)                     '((125 cmn::32nd)(167 cmn::ts)(200 (cmn::rq 1/5))(249 cmn::s)(250 cmn::s)                       (300 (cmn::rq 3/10))(333 cmn::te)(334 cmn::te)(375 cmn::s.)(400 (cmn::rq 2/5))(499 cmn::e)(500 cmn::e)(600 (cmn::rq 3/5))                       (667 cmn::tq)(666 cmn::tq)(750 cmn::e.)(800 (cmn::rq 4/5))                       (833 (cmn::rq 7/10))(999 cmn::q)(1000 cmn::q)(1200 (cmn::rq 6/5))(1250 (cmn::rq 5/4))(1333 cmn::th)(1332 cmn::th)(1334 cmn::th)                       (1500 cmn::q.)(1600 (cmn::rq 8/5))(1999 cmn::h)(2000 cmn::h)(2250 (cmn::rq 9/4))(2400 (cmn::rq 12/5))(2500 (cmn::rq 5/2))(2667 (cmn::rq 27/10))                       (3000 cmn::h.)(3200 (cmn::rq 16/5))(3250 (cmn::rq 13/4))(3999 cmn::w)(4000 cmn::w)(4800 (cmn::rq 24/5))(6000 cmn::w.)                       (8000 cmn::double-whole)))))));;;;;#|(remove-overlap-from-channels             '((0 55 750 1 64) (750 55 250 1 64) (1000 55 2000 1 64)               (3000 60 750 1 64) (3750 59 250 1 64) (4000 60 750 1 64)               (4750 62 250 1 64)))(((0 55 750 1 64)(750 55 250 1 64) . . .|#;;;;;(defun REMOVE-OVERLAP-FROM-CHANNELS (events)  "Removes overlapping events."  (loop for channel in (order-by-channels events)        collect (remove-overlap-from-channel channel)));;;;;#|(remove-overlap-from-channel              '((0 55 750 1 64) (750 55 250 1 64) (1000 55 2000 1 64)                (3000 60 750 1 64) (3750 59 250 1 64) (4000 60 750 1 64)                (4750 62 250 1 64)))((0 55 750 1 64)(750 55 250 1 64) . . . |#;;;;;(defun REMOVE-OVERLAP-FROM-CHANNEL (channel)  "Removes overlapping events."  (cond ((null (cdr channel)) (last channel))        ((or (<= (+ (very-first channel)(third (first channel)))                 (first (second channel)))             (equal (very-first channel)(first (second channel))))         (cons (first channel)(remove-overlap-from-channel (cdr channel))))        (t (cons (append (firstn 2 (first channel))                         (list (- (first (second channel))(very-first channel)))                         (nthcdr 3 (first channel)))                 (remove-overlap-from-channel (cdr channel))))));;;;;#|(translate-starts            '((0 55 750 1 64) (750 55 250 1 64) (1000 55 2000 1 64)             (3000 60 750 1 64) (3750 59 250 1 64) (4000 60 750 1 64)             (4750 62 250 1 64)))(((0 55 750 1 64) (750 55 250 1 64)(1000 55 2000 1 64) (3000 60 750 1 64) . . .|#;;;;;(defun TRANSLATE-STARTS (events)  "Translates the ontime of events."  (remove-overlap-from-channels (loop for event in events                                      collect (cons (translate-ontime (first event))                                                    (cdr event)))));;;;;#|(translate-ontime 0)    0|#;;;;;(defun TRANSLATE-ONTIME (ontime)  "Attempts to start on a beat."  (let* ((offbeat-time (mod ontime 1000))         (thousands (floor (/ ontime 1000))))    (if (member offbeat-time '(0 125 166 167 200 249 250 300 333 334 375 400 499 500 600 625 666 667 750 800 833 875))       ontime      (+ (* thousands 1000)         (find-closest offbeat-time                       '(125 166 167 200 249 250 300 333 334 375 400 499 500 600 625 666 667 750 800 833 875))))));;;;;#|(interpolate-rests              '((0 55 750 1 64) (750 55 250 1 64) (1000 55 2000 1 64)                (3000 60 750 1 64) (3750 59 250 1 64) (4000 60 750 1 64)                (4750 62 250 1 64)))     interpolate-rests returned ((0 55 750 1 64) (750 55 250 1 64)                                (1000 55 2000 1 64) (3000 60 750 1 64)                                (3750 59 250 1 64) (4000 60 750 1 64)                                (4750 62 250 1 64))|#;;;;;(defun INTERPOLATE-RESTS (events &optional (previous-time 0))  "This assumes that all of the events are in the same channel."  (cond ((null (cdr events)) events)        ((< (abs (- (very-first events) (first (second events)))) 20)         (cons (first events)               (interpolate-rests (cdr events) previous-time)))        ((< (abs (- (very-first events) previous-time)) 20)         (cons (first events)               (interpolate-rests (cdr events) (+ (very-first events)(third (first events))))))        (t (append (make-appropriate-rests previous-time (very-first events)(first events))                   (interpolate-rests (cdr events) (+ (very-first events)(third (first events))))))));;;;;#|(make-appropriate-rests 0 2000 '(0 60 1000 1 127))((0 0 2000 1 127) (0 60 1000 1 127))|#;;;;;(defun MAKE-APPROPRIATE-RESTS (previous-time current-time event)  "Creates appropriate silent events."  (append (make-appropriate previous-time current-time event)(list event)));;;;;#|(make-appropriate 0 2000 '(0 60 1000 1 127))((0 0 2000 1 127))|#;;;;;(defun MAKE-APPROPRIATE (previous-time current-time event)  "Creates an appropriate silent event."  (let* ((previous-time-offbeat (mod previous-time 1000))         (difference-to-next-onbeat (- 1000 previous-time-offbeat)))    (cond ((or (equal previous-time current-time)(> previous-time current-time))())          ((and (thousandp previous-time)(thousandp current-time))           (cons (create-a-rest previous-time (- current-time previous-time) event)                 (MAKE-APPROPRIATE current-time                                   current-time                                   event)))          ((equal previous-time (- current-time (mod current-time 1000)))           (cons (create-a-rest previous-time (mod current-time 1000) event)                 (MAKE-APPROPRIATE (+ (mod current-time 1000) previous-time)                                   current-time                                   event)))                    ((thousandp previous-time)           (cons (create-a-rest previous-time (- (- current-time (mod current-time 1000)) previous-time) event)                 (MAKE-APPROPRIATE (+ (- (- current-time (mod current-time 1000)) previous-time) previous-time)                                   current-time                                   event)))                    ((< (+ difference-to-next-onbeat previous-time) current-time)             (cons (create-a-rest previous-time difference-to-next-onbeat event)                 (MAKE-APPROPRIATE (+ difference-to-next-onbeat previous-time)                                   current-time                                   event)))          (t (cons (create-a-rest previous-time (- current-time previous-time) event)                   (MAKE-APPROPRIATE current-time                                     current-time                                     event))))));;;;;#|(create-a-rest 0 2000 '(0 60 1000 1 127))(0 0 2000 1 127)|#;;;;;(defun CREATE-A-REST (ontime duration event)"Actually creates an appropriate silent event."  (append (list ontime)          '(0)          (list duration)          (nthcdr 3 event)));;;;;#|(correct-for-errors ((0 60 1000 1 127)))   ((0 60 1000 1 127))|#;;;;;(defun CORRECT-FOR-ERRORS (events &optional (measure 1))  "This function attempts to account for discrepancies between the last note of a measure       and the following barline."  (cond ((null (cdr events)) events)        ((not (> (length (first events)) 5)) events)        ((equal (my-last (first events))(my-last (second events)))         (cons (first events)(correct-for-errors (cdr events) measure)))        (t (let ((end-time (* measure *meter* (/ 4000 *tactus*))))             (if (equal (+ (first (first events))                           (third (first events)))                        end-time)               (cons (first events)                     (correct-for-errors (cdr events)(1+ measure)))               (append (list (first events)                             (append (list (+ 10 (first (first events))))                                     '(0)                                     (nthcdr 2 (my-last events))))                       (correct-for-errors (cdr events)(1+ measure))))))));;;;;#|(order-by-channels           ((0 60 1000 4 127) (0 67 1000 2 127) (0 64 1000 3 127) (0 72 1000 1 127)            (1000 55 1000 4 127) (1000 67 1000 2 127) (1000 59 1000 3 127)...     (((0 72 1000 1 127) (1000 74 1000 1 127)       (2000 76 1000 1 127) (3000 74 1000 1 127)       (4000 72 1000 1 127) (5000 71 1000 1 127)       (6000 69 1000 1 127) (7000 67 1000 1 127))     ((0 67 1000 2 127) (1000 67 1000 2 127)..|#;;;;;(defun ORDER-BY-CHANNELS (events &optional (channel 1)(temp))  "Orders the arg by channel with channel 1 first."  (loop until (equal channel 17)        do (setf temp                  (sortcar '< (interpolate-rests (ensure-every-duration-the-same                                                  (get-channel channel events)))))        if temp        collect temp        do (setf channel (1+ channel))));;;;;#|(cmn #<self-acting #x176852E>              #<system #x17763B6>              #<self-acting #x177643E>...      #<score #x177775E>|#;;;;;(defun CMN (&rest objects)  "Score top-level."  (when objects				        ; if no args, Alice is a no-op    (unwind-protect      (catch 'cannot-open-file	                ; open file error aborts entire process        (cmn::cmn-finalize			; cleanup, return complete score structure (for subsequent editing)         (cmn::drawify			        ; drawify draws the result (normally creates a separate .eps file for each page)          (cmn::filterify			; filterify filters out "uninteresting" portions of the final score (for page extraction)           (cmn::slurify			; slurify adds slurs            (cmn::markify			; markify adds most marks like fingerings, staccato, sF, etc             (cmn::tieify			; tieify adds ties              (cmn::beamify		        ; beamify adds beams               (cmn::justify		        ; justify adds in white space to make each line and page look pretty                (cmn::pagify		        ; pagify breaks the linified form into pages                 (cmn::linify		        ; linify breaks the compacted form into lines                  (cmn::compactify		; compactify aligns boxes across all systems                   (cmn::boxify		        ; boxify finds bounding boxes and center points                    (cmn::fillify		; fillify does the first level of filling in missing data (bar lines, rests etc)                     (cmn::scorify		; scorify (via notify) regularizes the input stream of objects                      (cmn::edify		; edify filters out all but "interesting" data (i.e. for part extraction, transposition, etc)                       (cmn::cmn-initialize objects)))))))))))))))))      (progn	(if (and cmn::*cmn-score* 		 (eq (cmn::output-type cmn::*cmn-score*) :C))          (progn            (setf (cmn::output-type cmn::*cmn-score*) nil)            (setf cmn::*cmn-initialized* nil)            (cmn::c-close)))	(if (not cmn::no-initialization)          (setf cmn::tie-stack nil                cmn::slur-stack nil                cmn::glissando-stack nil                cmn::crescendo-stack nil                cmn::tremolo-stack nil                cmn::text-stack nil                cmn::rehearsal-stack nil                cmn::beam-stack nil                cmn::octave-stack nil                cmn::cmn-pipe-0 nil                cmn::cmn-pipe-1 nil                cmn::cmn-pipe-2 nil                cmn::*cmn-hidden-sections* nil                cmn::*cmn-score-size* nil                cmn::*old-cmn-score-size* nil                cmn::*cmn-system* nil                cmn::*cmn-staff* nil                cmn::*cmn-staff-data* nil                cmn::*cmn-page* nil                cmn::*cmn-object* nil                cmn::*cmn-owning-object* nil))))));;;;;#|(EVENTS? '((0 60 1000 1 60) (0 48 1000 2 60)))      t|#;;;;;(defun EVENTS? (stuff)  "Returns t if all of the arg are events."  (and (not (symbolp (first stuff)))       (numberp (very-first stuff))));;;;;#|(GET-WEIGHTED-SCALE duet)   ((c 147) (d 65) (e 49) (f 16) (g 16) (b 67))|#;;;;;(defun GET-WEIGHTED-SCALE (events)  "Returns a weighted scale."  (setq *first-test* (mapcar #'(lambda (x)(funcall 'second x))                                       events))  (setq *second-test* (collect-the-pitch-classes (capture-pitch-classes *first-test*)))  (setq *third-test* (create-slice-of-pie (/ 360 (length *first-test*)) *second-test*)));;;;;#|(DISCOVER-SIGNATURE duet)      sharp|#;;;;;(defun DISCOVER-SIGNATURE (events)  "Returns sharp or flat for signature creation."  (get-weighted-scale events)  (setq *column-info* (find-scale *third-test*))  (setq *scale-info* (make-an-educated-guess-as-to-scale                       (convert-pitch-classes (convert-pitch-names *column-info*))))  (let ((key (list (very-first *column-info*)(first *scale-info*))))    (cond ((and (equal (second key) 'major) (member (first key) *sharp-major-keys*))           'sharp)          ((and (or (equal (second key) 'nat-minor)(equal (second key) 'harm-minor))                (member (first key) *sharp-minor-keys*))           'sharp)          (t 'flat))));;;;;#||#;;;;;(defun ENSURE-EVERY-DURATION-THE-SAME (events)  "Requires one channel of information."  (apply #'append (ensure-same-durations events)));;;;;#|(ENSURE-SAME-DURATIONS duet)       (((0 60 1000 1 60) (0 48 1000 2 60)) ((1000 62 1000 1 60) (1000 47 1000 2 60))        ((2000 64 1000 1 60) (2000 48 1000 2 60))..|#;;;;;(defun ENSURE-SAME-DURATIONS (events)  "Returns t if same-durationed events."  (let ((test (collect-all-the-same-ontimes events)))    (loop for grouped-events in test          collect (let ((duration (find-shortest-duration grouped-events)))                    (loop for event in grouped-events                          collect (append (firstn 2 event)                                          (list duration)                                          (nthcdr 3 event)))))));;;;;#|(COLLECT-ALL-THE-SAME-ONTIMES duet)   (((0 60 1000 1 60) (0 48 1000 2 60)) ((1000 62 1000 1 60) (1000 47 1000 2 60))    ((2000 64 1000 1 60) (2000 48 1000 2 60))....|#;;;;;(defun COLLECT-ALL-THE-SAME-ONTIMES (events)  "Collects the same ontimed events."  (if (null events)()      (let ((test (collect-same-ontimes events (very-first events))))        (cons test              (collect-all-the-same-ontimes (nthcdr (length test) events))))));;;;;#| (collect-same-ontimes           '((14000 74 2000 1 60) (14000 47 2000 2 60))           14000) ((14000 74 2000 1 60) (14000 47 2000 2 60)|#;;;;;(defun COLLECT-SAME-ONTIMES (events ontime)  "Collects the same ontime events."  (if (eq (very-first events) ontime)    (cons (first events)          (collect-same-ontimes (cdr events) ontime))));;;;;#|(find-shortest-duration           '((0 60 1000 1 60) (0 48 1000 2 60) (1000 62 1000 1 60)            (1000 47 1000 2 60) (2000 64 1000 1 60) (2000 48 1000 2 60)...     1000|#;;;;;(defun FIND-SHORTEST-DURATION (events)  "Returns the shortest duration."  (first (sort (loop for event in events                     collect (third event)) '<)))
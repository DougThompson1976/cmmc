                   ;;;;;COMPUTER MODELS OF MUSICAL CREATIVITY;;;;;                   ;;;;;            By David Cope            ;;;;;                   ;;;;;     Sorcerer Function/Chapter 5     ;;;;;                   ;;;;;             COMMON LISP             ;;;;;                   ;;;;;     basic code to run sorcerer      ;;;;;                   ;;;;;               function              ;;;;;                   ;;;;;COMPUTER MODELS OF MUSICAL CREATIVITY;;;;;(require :scrollers)(ccl:require :quickdraw)(defVar *CMN-OUTPUT-PATHNAME* "Macintosh HD:Applications:MCL 4.0:sorcerer")(defVar *ALICE-OUTPUT-PATHNAME* "Macintosh HD:Applications:MCL 4.0:sorcerer")(if (not (boundp 'cmn-directory))   (setf cmn-directory         (namestring         (truename 	  (directory-namestring 	   (or #+(and gcl (not cltl2)) si:*load-pathname* 	       #+(and excl (not cltl2)) excl:*source-pathname*	       #+(or cltl2 (and (not excl) (not gcl))) *load-pathname* 	       "./"))))))(if (not (boundp 'pcl-directory)) (setf pcl-directory "/dist/lisp/pcl2c/"))(if (not (boundp 'cmn-bin-directory)) (setf cmn-bin-directory cmn-directory))(defVar *MAXIMUM* 8 "Maximum phrase length for matching in beats.")(defVar *DATABASE-NAMES* () "The database names storage.")(defVar *TARGET-NAME* () "Target name storage.")(defVar *DATABASE-NAMES-SAVE* ())(defVar *PATTERNS* () "Pattern storage.")(defVar *WORK* () "Work name.")(defVar TEST ())(defVar *WINDOW* ())(defVar *SOURCE-POSITION* 1)(defVar *TARGET-POSITION* 1)(defVar *CHOICE* ())(defVar *LIST-OF-SOURSES* ())(defVar *COUNT* 0)(defVar *TIMING* 0)(defVar *RESULT* ())(defVar *TEST* ())(defVar *SCORE-NAME* 'sorcerer);;;  the top level of sorcerer;;;;;#|(sorcerer 'bach-1 '(beet-2)) #<score-floating-window "" #xFF46B46>|#;;;;;(defun SORCERER (target-phrase database-works)"The top-level matching function of sorcerer."  (setq *source-position* 1)  (setq *choice* t)  (setq *target-position* 1)  (setq *target-name* target-phrase)  (setq *database-names* database-works)  (setq *database-names-save* *database-names*)  (source-it (eval target-phrase)              (loop for work in database-works                    collect (eval work))));;;;;#|(find-the-patterns             '((0 71 500 1 64) (500 74 500 1 64) (1000 78 500 1 64)              (1500 83 1000 1 64) (2500 81 500 1 64) (3000 83 1000 1 64))             '(((0 77 500 1 64) (500 82 1500 1 64) (2000 81 250 1 64)               (2250 82 250 1 64) (2500 84 500 1 64) (3000 82 500 1 64))))(((x x 5 -1 1) beet-2))|#;;;;;(defun FIND-THE-PATTERNS (target-work-name names-of-database-works)  "Runs the matcher on intervals rather than pitches."  (find-patterns (get-intervals target-work-name)                 names-of-database-works));;;;;#|(source-it '((0 71 500 1 64) (500 74 500 1 64) (1000 78 500 1 64)                      (1500 83 1000 1 64) (2500 81 500 1 64)                      (3000 83 1000 1 64))             '(((0 77 500 1 64) (500 82 1500 1 64) (2000 81 250 1 64)                       (2250 82 250 1 64) (2500 84 500 1 64)                       (3000 82 500 1 64))))#<score-floating-window "" #xFF46B46>|#;;;;;(defun SOURCE-IT (target list-of-sources)  "Runs the basic grunt functions of the matcher."  (setq *score-name* *target-name*)  (setq *work* (list (get-intervals target) *target-name*))  (setq *list-of-sourses* list-of-sources)  (setq *test* *list-of-sourses*)  (setq *patterns* (find-the-patterns target list-of-sources))  (setq *database-names* *database-names-save*)  (setq *count* 1)  (setq *result* (sortcar '< (apply #'append (cons target                                       (loop for pattern in *patterns*                                             do (setf *count* (1+ *count*))                                             do (setf *timing* (get-timing target (car pattern)))                                             unless (null *timing*)                                             collect (change-channel (add-timing *timing* (first *list-of-sourses*)) *count*)                                             do (setf *list-of-sourses* (cdr *list-of-sourses*)))))))  (setq *DYNAMICS-SIZE* 0.0)  (gc)  (unless (null *result*)(progn                            (funcall #'translate-to-Alice-notation 32 *result*)                           (make-instance 'score-floating-window))));;;;;#|(add-timing 1000 '((0 77 500 1 64) (500 82 1500 1 64) (2000 81 250 1 64)                     (2250 82 250 1 64) (2500 84 500 1 64)                     (3000 82 500 1 64)))((1000 77 500 1 64) (1500 82 1500 1 64)  (3000 81 250 1 64) (3250 82 250 1 64)   (3500 84 500 1 64) (4000 82 500 1 64))|#;;;;;(defun ADD-TIMING (timing events)  "Adds timing to the ontimes of events."  (loop for event in events        collect (cons (+ timing (first event))                      (cdr event))));;;;;#|(get-timing '((0 71 500 1 64) (500 74 500 1 64) (1000 78 500 1 64)                        (1500 83 1000 1 64) (2500 81 500 1 64)                        (3000 83 1000 1 64))             '(x x 5 -1 1))   1000|#;;;;;(defun GET-TIMING (source-events xd-source-list)  "This gets the timing of the source work."  (let ((test (count-xs xd-source-list)))    (if test       (car (nth (count-xs xd-source-list) source-events)))));;;;;#|(change-channel             '((1000 77 500 1 64) (1500 82 1500 1 64) (3000 81 250 1 64)              (3250 82 250 1 64) (3500 84 500 1 64) (4000 82 500 1 64))             2)((1000 77 500 2 64) (1500 82 1500 2 64)                            (3000 81 250 2 64) (3250 82 250 2 64)                            (3500 84 500 2 64) (4000 82 500 2 64))|#;;;;;(defun CHANGE-CHANNEL (music channel)  "Changes the channel of music to channel."    (if (null music)()        (cons (append (firstn 3 (first music))                      (list channel)                      (nthcdr 4 (first music)))              (change-channel (cdr music) channel))));;;;;#|(count-xs '(x x 5 -1 1)) 2|#;;;;;(defun COUNT-XS (list &optional (n 0))   "Counts the x's in the list."  (cond ((null list)())        ((not (equal (first list) 'x))          n)        (t (count-xs (cdr list) (1+ n)))));;;;;#|(find-patterns              '(3 4 5 -2 2)              '(((0 77 500 1 64) (500 82 1500 1 64) (2000 81 250 1 64)                (2250 82 250 1 64) (2500 84 500 1 64) (3000 82 500 1 64))))(((x x 5 -1 1) beet-2))|#;;;;;(defun FIND-PATTERNS (target-pattern names-of-database-works)  "Funs the basic pattern matcher."  (cond ((null names-of-database-works)())        ((setq test (pattern-match target-pattern                                   (get-intervals (first names-of-database-works))))         (cons (list test (pop *database-names*))               (find-patterns target-pattern (cdr names-of-database-works))))        (t (find-patterns target-pattern (cdr names-of-database-works)))));;;;;#|(pattern-match '(3 4 5 -2 2) '(5 -1 1 2 -2))(x x 5 -1 1)|#;;;;;(defun PATTERN-MATCH (target-pattern-list source-pattern-list &optional (last-interval 0)(initial t))  "The basic pattern matcher."  (cond ((and (null target-pattern-list)              (null source-pattern-list)) ())        ((null target-pattern-list)())        ((null source-pattern-list)          (cons 'x                (pattern-match (cdr target-pattern-list) source-pattern-list (first target-pattern-list))))        ((or (match (+ (first target-pattern-list) last-interval)                    (first source-pattern-list))             (equal (invert (+ (first target-pattern-list) last-interval))(first source-pattern-list)))         (cons (first source-pattern-list)               (pattern-match (cdr target-pattern-list)(cdr source-pattern-list) 0 nil)))        (t (cons 'x                  (pattern-match (cdr target-pattern-list) source-pattern-list                                 (if initial 0 (+ last-interval (first target-pattern-list)))                                 initial)))));;;;;#|(invert 3)    -9|#;;;;;(defun INVERT (interval)  "Inverst the interval mod 23."  (- interval 12));;;;;#|(match 5 5)  t|#;;;;;(defun MATCH (subject object)  "A simple matcher."  (cond ((equal subject object))        ((and (member subject '(1 2))(member object '(1 2))))        ((and (member subject '(3 4))(member object '(3 4))))        ((and (member subject '(5 6))(member object '(5 6))))        ((and (member subject '(8 9))(member object '(8 9))))        ((and (member subject '(10 11))(member object '(10 11))))        ((and (member subject '(-1 -2))(member object '(-1 -2))))        ((and (member subject '(-3 -4))(member object '(-3 -4))))        ((and (member subject '(-5 -6))(member object '(-5 -6))))        ((and (member subject '(-8 -9))(member object '(-8 -9))))        ((and (member subject '(-10 -11))(member object '(-10 -11))))        (t ())));;;;;#|(get-intervals             '((0 71 500 1 64) (500 74 500 1 64) (1000 78 500 1 64)              (1500 83 1000 1 64) (2500 81 500 1 64) (3000 83 1000 1 64)))   (3 4 5 -2 2)|#;;;;;(defun GET-INTERVALS (events)  "Returns intervals for pitches."  (if (null (cdr events))()      (cons (- (second (second events))(second (first events)))            (get-intervals (cdr events)))));;;;;#|(create-number-series 1 3 12)     (1 4 7 10)|#;;;;;(defun CREATE-NUMBER-SERIES (n add limit)  "Creates a number series limit long and incrementing by add."  (if (> n limit)()      (cons n            (create-number-series (+ add n) add limit))))(defVar *BEGIN* 200)(defVar *COLUMNS* (create-number-series 200 60 1500))(defClass SCROLLING-WINDOW-SCROLLER1 (scroller)    ((patterns :initarg :patterns :initform *patterns* :accessor patterns))  (:default-initargs    :field-size (make-point 330 330)))(defMethod VIEW-DRAW-CONTENTS ((window SCROLLING-WINDOW-SCROLLER1))  (call-next-method)  (setq *begin* 120)  (setq *columns* (create-number-series 200 40 1500))  (set-view-font window :plain)  (set-view-font window 18)  (set-view-font window "times")  (move-to window (make-point 10 20))  (format window "~A~A~A" "This begins on the " *target-position* " position of the target work.")  (move-to window (make-point 10 40))  (format window "~A~A~A" "This begins on the " *source-position* " position of the database works.")  (move-to window (make-point 10 70))  (format window "~A" "Target:")  (move-to window (make-point 10 120))  (format window "~A" "Sources:")  (move-to window (make-point 100 70))  (format window "~A" (second *work*))  (setq *columns* (create-number-series 200 40 1500))  (loop for entry in (first *work*)        do (move-to window (make-point (pop *columns*) 70))        do (format window "~A" entry))  (move-to window (make-point 100 *begin*))  (loop for entry in (patterns window)        do (format window "~A~A" (second entry) "      ")        do (setq *columns* (create-number-series 200 40 1500))        do (loop for entry in (first entry)                 do (move-to window (make-point (pop *columns*) *begin*))                 do (format window "~A" entry))        do (setq *begin* (+ *begin* 20))        do (move-to window (make-point 100 *begin*))))(defClass SCROLLING-WINDOW (window) ((my-scroller :accessor my-scroller)))(defMethod INITIALIZE-INSTANCE ((self SCROLLING-WINDOW) &rest rest &key                                    (scroller-class 'scroller)                                    scroll-bar-class h-scroll-class v-scroll-class                                    track-thumb-p field-size)  (declare (dynamic-extent rest))  ; We use the values of these keywords by modifying the rest parameter  (declare (ignore scroll-bar-class h-scroll-class v-scroll-class                   track-thumb-p field-size))  (call-next-method)  ; Leave, in rest, only the four keywords we want to pass to the  ; make-instance for scroller-class. This allows them to default  ; as desired by scroll-class.  (let* ((handle (cons nil rest)))    (declare (dynamic-extent handle) (type cons handle))    (do ((tail handle))        ((null (cdr tail)) (setq rest (cdr handle)))      (declare (type cons tail))      (if (memq (cadr tail)                 '(:scroll-bar-class :h-scroll-class :v-scroll-class                  :track-thumb-p :field-size))        (setq tail (cddr tail))        (setf (cdr tail) (cdr (cddr tail))))))  (setf (my-scroller self) (apply #'make-instance                                  scroller-class                                  :view-container self                                  :view-size (subtract-points                                              (view-size self) #@(15 15))                                  :view-position #@(0 0)                                  :draw-scroller-outline nil                                  rest)))(defMethod SET-VIEW-SIZE ((self SCROLLING-WINDOW) h &optional v)  (declare (ignore h v))  (without-interrupts   (call-next-method)   (let* ((new-size (subtract-points (view-size self) #@(15 15))))         (set-view-size (my-scroller self) new-size))))(defMethod WINDOW-ZOOM-EVENT-HANDLER ((self SCROLLING-WINDOW) message)  (declare (ignore message))  (without-interrupts   (call-next-method)   (let* ((new-size (subtract-points (view-size self) #@(15 15))))     (set-view-size (my-scroller self) new-size))));;;  test data(defVar *CHOICES* '(chopin-1 bach-1 bach-2 bach-3 bach-4 beet-1 beet-2 bocc-1 c-1 s-1))(setq chopin-1 '((0 59 1000 1 64)(1000 64 1500 1 64)(2500 63 500 1 64)(3000 64 500 1 64)(3500 67 500 1 64)(4000 71 1000 1 64)(5000 71 1000 1 64)(6000 71 1000 1 64)(7000 76 1000 1 64)(8000 75 500 1 64)(8500 76 500 1 64)(9000 78 750 1 64)(9750 76 250 1 64)(10000 76 1000 1 64)(11000 75 1000 1 64)))(setq Bach-1 '((0 71 500 1 64)(500 74 500 1 64)(1000 78 500 1 64)(1500 83 1000 1 64)(2500 81 500 1 64)(3000 83 1000 1 64)))(setq Bach-2 '((0 64 250 1 64)(250 67 250 1 64)(500 71 250 1 64)(750 76 250 1 64)(1000 75 250 1 64)(1250 76 250 1 64)))(setq Bach-3 '((0 69 500 1 64)(500 62 500 1 64)(1000 65 500 1 64)(1500 69 500 1 64)(2000 74 500 1 64)(2500 76 500 1 64)))(setq Bach-4 '((0 52 500 1 64)(500 57 500 1 64)(1000 60 500 1 64)(1500 64 500 1 64)(2000 69 500 1 64)(2500 68 500 1 64)(3000 69 500 1 64)(3500 59 500 1 64)))(setq Beet-1 '((0 55 750 1 64)(750 55 250 1 64)(1000 55 2000 1 64)(3000 60 750 1 64)(3750 59 250 1 64)(4000 60 750 1 64)(4750 62 250 1 64)))(setq Beet-2 '((0 77 500 1 64)(500 82 1500 1 64)(2000 81 250 1 64)(2250 82 250 1 64)(2500 84 500 1 64)(3000 82 500 1 64)))(setq Bocc-1 '((0 81 250 1 64)(250 80 250 1 64)(500 81 250 1 64)(750 83 250 1 64)(1000 81 500 1 64)))(setq c-1 '((0 58 2000 1 64)(2000 63 1000 1 64)(3000 62 1000 1 64)(4000 63 1000 1 64)(5000 66 1000 1 64)(6000 70 1000 1 64)(7000 70 3000 1 64)(10000 75 1000 1 64)))(setq s-1 '((0 60 1000 1 64)(1000 65 2500 1 64)(3500 64 500 1 64)(4000 65 500 1 64)(4500 69 500 1 64)(5000 72 1000 1 64)(6000 77 2000 1 64)(8000 76 1000 1 64)));;;;;#|(check-for-overlap '((1000 77 500 2 64) (1500 82 1500 2 64)                       (3000 81 250 2 64) (3250 82 250 2 64)                       (3500 84 500 2 64) (4000 82 500 2 64)))   okay|#;;;;;(defun CHECK-FOR-OVERLAP (events)  "Checks for overlapping events."  (cond ((null (cdr events)) 'okay)        ((equal (+ (first (first events))(third (first events)))                (first (second events)))         (check-for-overlap (cdr events)))        (t ())))
                   ;;;;;COMPUTER MODELS OF MUSICAL CREATIVITY;;;;;                   ;;;;;            By David Cope            ;;;;;                   ;;;;;     Sorcerer Function/Chapter 5     ;;;;;                   ;;;;;             COMMON LISP             ;;;;;                   ;;;;;    charts code to run sorcerer      ;;;;;                   ;;;;;               function              ;;;;;                   ;;;;;COMPUTER MODELS OF MUSICAL CREATIVITY;;;;;;;;;;#|(capture-pitch-classes (57))   (a)|#;;;;;(defun CAPTURE-PITCH-CLASSES (midi-notes)  "Returns the appropriate pitch names.)"  (cond ((null midi-notes)())        ((member (first midi-notes) '(24 36 48 60 72 84 96 108))         (cons 'c (capture-pitch-classes (cdr midi-notes))))        ((member (first midi-notes) '(25 37 49 61 73 85 97 109))         (cons 'db (capture-pitch-classes (cdr midi-notes))))        ((member (first midi-notes) '(26 38 50 62 74 86 98 110))         (cons 'd (capture-pitch-classes (cdr midi-notes))))        ((member (first midi-notes) '(27 39 51 63 75 87 99 111))         (cons 'eb (capture-pitch-classes (cdr midi-notes))))        ((member (first midi-notes) '(28 40 52 64 76 88 100 112))         (cons 'e (capture-pitch-classes (cdr midi-notes))))        ((member (first midi-notes) '(29 41 53 65 77 89 101 113))         (cons 'f (capture-pitch-classes (cdr midi-notes))))        ((member (first midi-notes) '(30 42 54 66 78 90 102 114))         (cons 'gb (capture-pitch-classes (cdr midi-notes))))        ((member (first midi-notes) '(31 43 55 67 79 91 103 115))         (cons 'g (capture-pitch-classes (cdr midi-notes))))        ((member (first midi-notes) '(32 44 56 68 80 92 104 116))         (cons 'ab (capture-pitch-classes (cdr midi-notes))))        ((member (first midi-notes) '(33 45 57 69 81 93 105 117))         (cons 'a (capture-pitch-classes (cdr midi-notes))))        ((member (first midi-notes) '(34 46 58 70 82 94 106 118))         (cons 'bb (capture-pitch-classes (cdr midi-notes))))        ((member (first midi-notes) '(35 47 59 71 83 95 107 119))         (cons 'b (capture-pitch-classes (cdr midi-notes))))));;;;;#|(collect-pitch-classes           '(c g e c g g b d c g c e b d a d gb e e g c gb a g d b b g c d g d a            gb a g g b g))    ((c 6) (d 6) (e 4) (gb 3) (g 11) (a 4) (b 5))|#;;;;;(defun COLLECT-PITCH-CLASSES (pitches &optional (classes '(c db d eb e f gb g ab a bb b)))  "Collects the various pitches and their relative strength."  (if (null pitches)()      (cons (list (first pitches)(count (first pitches) classes :test #'equal))            (collect-pitch-classes (cdr pitches) classes))));;;;;#|(collect-the-pitch-classes           '(c g e c g g b d c g c e b d a d gb e e g c gb a g d b b g c d g d a             gb a g g b g))    ((c 6) (d 6) (e 4) (gb 3) (g 11) (a 4) (b 5))|#;;;;;(defun COLLECT-THE-PITCH-CLASSES (pitches &optional (classes '(c db d eb e f gb g ab a bb b)))  "Counts the number of each element in its arg."  (cond ((null classes)())        ((not (zerop (count (first classes) pitches)))         (cons (list (first classes)(count (first classes) pitches))               (collect-the-pitch-classes pitches (cdr classes))))        (t (collect-the-pitch-classes pitches (cdr classes)))));;;;;#|(count-the-members '(1 2 3 4))((1 1) (2 1) (3 1) (4 1))|#;;;;;(defun COUNT-THE-MEMBERS (list)  "Counts the number of each element in its arg."  (if (null list)()      (let ((count (list (first list)(count (first list) list))))        (cons count (count-the-members (remove (first list) list))))));;;;;#|(get-the-intervals '((60 64)))((ma3 1))|#;;;;;(defun GET-THE-INTERVALS (channel-pitches)  "Returns interval names and number."  (count-the-members    (mapcar #'(lambda (x)(second (assoc x *intervals*)))           (sort (apply #'append                         (mapcar #'(lambda (x)                                    (interval-class-translator x))                                channel-pitches)) #'<))));;;;;#|(interval-class-translator '(64 67))(3)|#;;;;;(defun INTERVAL-CLASS-TRANSLATOR (pitches)  "Produces intervals from pitches."  (mapcar #'reduce-interval (mapcar #' abs (make-intervals pitches))));;;;;#|(reduce-interval 64)4|#;;;;;(defun REDUCE-INTERVAL (interval)  "Used only for intervals - mod 12."  (if (<= interval 11) interval (reduce-interval (- interval 12))))(setq *intervals* '((0 u)(1 mi2)(2 ma2)(3 mi3)(4 ma3)(5 p4)(6 a4)(7 p5)(8 mi6)(9 ma6)                    (10 mi7)(11 ma7)));;;;;#|(collect-weighted-pitches '((0 64 1000 1 124)))(64)|#;;;;;(defun COLLECT-WEIGHTED-PITCHES (events)  "Used only for intervals."  (if (null events)()      (append (weight-pitch (first events))              (collect-weighted-pitches (cdr events)))));;;;;#|(weight-pitch '(0 64 1000 1 124))(64)|#;;;;;(defun WEIGHT-PITCH (event &optional (weight (third event)))  "Used only for intervals."  (if (< weight 125)()      (cons (second event)            (weight-pitch event (- weight 1000)))));;;;;#|(make-column-graph)    (major polytonal)|#;;;;;(defun MAKE-COLUMN-GRAPH ()  "Makes the column graph."  (setq *channel-choice* ())  (setq x-place 0)  (if (null *third-test*)(message-dialog "Set Music!"))  (setq *column-info* (find-scale *third-test*))  (setq *scale-info* (make-an-educated-guess-as-to-scale                       (convert-pitch-classes (convert-pitch-names *column-info*)))));;;;;#|(make-new-column-graph)    (major polytonal)|#;;;;;(defun MAKE-NEW-COLUMN-GRAPH ()  "Makes the column graph."  (setq *channel-choice* t)  (setq *active-channels* (get-active-channels (eval (first (eval *selection*)))))  (make-instance 'my-channel-window));;;;;#|(convert-pitch-names           '((g 102) (a 37) (b 46) (c 55) (d 55) (e 37) (gb 28)))     ((67 102) (69 37) (71 46) (60 55) (62 55) (64 37)      (66 28))|#;;;;;(defun CONVERT-PITCH-NAMES (column-info)  "Converts the column info to pitch numbers."  (loop for item in column-info        collect (list (convert (first item))(second item))));;;;;#|(convert e)    64|#;;;;;(defun CONVERT (pitch-name)  "Returns number from symbol."  (cond ((equal pitch-name 'c) 60)        ((equal pitch-name 'db) 61)        ((equal pitch-name 'd) 62)        ((equal pitch-name 'eb) 63)        ((equal pitch-name 'e) 64)        ((equal pitch-name 'f) 65)        ((equal pitch-name 'gb) 66)        ((equal pitch-name 'g) 67)        ((equal pitch-name 'ab) 68)        ((equal pitch-name 'a) 69)        ((equal pitch-name 'bb) 70)        ((equal pitch-name 'b) 71)));;;;;#|(find-scale '((c 55) (d 55) (e 37) (gb 28) (g 102) (a 37) (b 46)))    ((g 102) (a 37) (b 46) (c 55) (d 55) (e 37) (gb 28))|#;;;;;(defun FIND-SCALE (ordered-notes-and-percents)  "Rotates to the highest note."  (if (equal (length ordered-notes-and-percents) 1)    ordered-notes-and-percents    (compare-results (rotate-to-highest ordered-notes-and-percents)                     (rotate-to-second-highest ordered-notes-and-percents))));;;;;#||#;;;;;(defun ROTATE-TO-HIGHEST (ordered-notes-and-percents)  "Calling (rotate-to-highest           ((c 55) (d 55) (e 37) (gb 28) (g 102) (a 37) (b 46)))     rotate-to-highest returned ((g 102) (a 37) (b 46) (c 55) (d 55) (e 37) (gb 28))"  (rotate-to-h ordered-notes-and-percents                (first (sort (mapcar #'second ordered-notes-and-percents) '>))));;;;;#|(rotate-to-h '((c 55) (d 55) (e 37) (gb 28) (g 102) (a 37) (b 46)) 102)     ((g 102) (a 37) (b 46) (c 55) (d 55) (e 37) (gb 28))|#;;;;; (defun ROTATE-TO-H (ordered-notes-and-percents highest-note)  "Rotates to highest note."  (cond ((null ordered-notes-and-percents)())        ((equal highest-note (second (first ordered-notes-and-percents)))         ordered-notes-and-percents)        (t (rotate-to-h             (append (cdr ordered-notes-and-percents)                    (list (first ordered-notes-and-percents))) highest-note))));;;;;#|(rotate-to-second-highest           '((c 55) (d 55) (e 37) (gb 28) (g 102) (a 37) (b 46)))     ((c 55) (d 55) (e 37) (gb 28) (g 102) (a 37)     (b 46))|#;;;;;(defun ROTATE-TO-SECOND-HIGHEST (ordered-notes-and-percents)  "Rotate the ordered notes appropriately."  (rotate-to-s ordered-notes-and-percents                (second (sort (mapcar #'second ordered-notes-and-percents) '>))));;;;;#| (rotate-to-s '((c 55) (d 55) (e 37) (gb 28) (g 102) (a 37) (b 46)) 55)     ((c 55) (d 55) (e 37) (gb 28) (g 102) (a 37) (b 46))|#;;;;;(defun ROTATE-TO-S (ordered-notes-and-percents highest-note)  "Rotates to get appropriate order of notes in a scale."  (cond ((null ordered-notes-and-percents)())        ((equal highest-note (second (first ordered-notes-and-percents)))         ordered-notes-and-percents)        (t (rotate-to-s             (append (cdr ordered-notes-and-percents)                    (list (first ordered-notes-and-percents))) highest-note))));;;;;#| (compare-results           '((g 102) (a 37) (b 46) (c 55) (d 55) (e 37) (gb 28))           '((c 55) (d 55) (e 37) (gb 28) (g 102) (a 37) (b 46)))      ((g 102) (a 37) (b 46) (c 55) (d 55) (e 37) (gb 28))|#;;;;;(defun COMPARE-RESULTS (highest-sort second-highest-sort)  "Compares its two args for highest sort."  (cond ((equal (second (first second-highest-sort)) (second (sixth highest-sort)))         highest-sort)        ((equal (second (first highest-sort)) (second (sixth second-highest-sort)))         second-highest-sort)        (t highest-sort)));;;;;#|(make-an-educated-guess-as-to-scale '((60 2)(62 2)(64 2)(66 2)))    (lydian whole-tone)|#;;;;;(defun MAKE-AN-EDUCATED-GUESS-AS-TO-SCALE (notes-and-ratings)  "Makes the best guess for scale."  (unless (null notes-and-ratings)    (let ((trial (make-an-educated-guess notes-and-ratings)))      (if trial (list trial)          (let ((test (make-an-educated-guess (remove-below-the-line notes-and-ratings))))            (if test (list test) (compare (remove-below-the-line notes-and-ratings)                                           (remove-special-forms notes-and-ratings *scales*))))))));;;;;#|(make-an-educated-guess '((60 2) (62 2) (64 2) (66 2)))     nil|#;;;;;(defun MAKE-AN-EDUCATED-GUESS (notes-and-ratings)  "Makes the best guess as to the scale used."  (if (null notes-and-ratings)()      (let ((scale (find-the-scale (make-intervals (mapcar #'first notes-and-ratings)))))        (if scale scale            (make-an-educated-guess (remove-less-weighted notes-and-ratings))))));;;;;#|(find-the-scale '(2 2 -11 2 2 2))     nil|#;;;;;(defun FIND-THE-SCALE (intervals)  "Attempts to find the scale of arg."  (let ((test (assoc intervals (remove-special-forms intervals *scales*) :test #'equal)))    (if test (second test))));;;;;#|(remove-less-weighted '((67 102) (62 55)))     ((67 102))|#;;;;;(defun REMOVE-LESS-WEIGHTED (notes-and-ratings)  "Removes the lower weighted ones."  (let ((test (first (sort (mapcar #'second notes-and-ratings) #'<))))    (remove (rassoc (list test) notes-and-ratings :test #'equal) notes-and-ratings :test #'equal)));;;;;#|(compare '((60 2) (62 2) (64 2) (66 2))           '(((2 2 1 2 2 2) major) ((2 1 2 2 1 2) nat-minor) . . .(lydian whole-tone)|#;;;;;(defun COMPARE (notes-and-ratings scales)  "Returns its best guesses for scales."  (let* ((the-scale (define-the-proper-intervals (mapcar #'first notes-and-ratings)))         (test (mapcar #'(lambda (x)(count-the-nodes                                     the-scale (first x))) scales)))    (find-the-best-choices test scales)));;;;;#|(count-the-nodes '(2 2 1 2 2 2) '(2 1 1 1 2 1 1 1 1))      7|#;;;;;(defun COUNT-THE-NODES (intervals scale)  "Counts the nodes."  (let ((count (apply #'+ (count-nodes (make-the-nodes intervals)                                       (make-the-nodes scale)))))    (if (equal (first intervals)(first scale)) count (1- count))));;;;;#|(make-the-nodes (2 2 1 2 2 2))     (0 2 4 5 7 9 11)|#;;;;;(defun MAKE-THE-NODES (intervals &optional (total 0))  "Enacts special cases."  (if (or (null intervals)(equal (first intervals) '*))(list total)      (cons total            (make-the-nodes (cdr intervals)                            (+ (first intervals) total)))));;;;;#|(count-nodes (0 2 4 5 7 9 11) (0 1 2 3 4 5 6 7))     (1 1 1 1 1 0 0)|#;;;;;(defun COUNT-NODES  (nodes1 nodes2)  "Counts the number of first arg in second arg."  (if (null nodes1)()      (cons (count (first nodes1) nodes2)            (count-nodes (cdr nodes1) nodes2))));;;;;#|(convert-pitch-classes           '((67 102) (69 37) (71 46) (60 55) (62 55) (64 37) (66 28)))     ((67 102) (69 37) (71 46) (60 55) (62 55)     (64 37) (66 28))|#;;;;;(defun CONVERT-PITCH-CLASSES (pcs-in-list &optional (begin? t))  "Evals list for note-names to numbers."  (cond ((null pcs-in-list)())        ((and (null begin?)(zerop (eval (very-first pcs-in-list))))         (cons (list 12 (second (first pcs-in-list)))               (convert-pitch-classes (cdr pcs-in-list) ())))        (t (cons (list (eval (very-first pcs-in-list))(second (first pcs-in-list)))                 (convert-pitch-classes (cdr pcs-in-list) ())))));;;;;#|(find-the-best-choices           '(7 4 5 5 2 6 6 1 5 3 3 3 4 7 6 4)           '(((2 2 1 2 2 2) major) ((2 1 2 2 1 2) nat-minor)...  (major polytonal)|#;;;;;(defun FIND-THE-BEST-CHOICES (counts scales)  "Returns the best choice for type and scale."  (find-the-best (first (my-sort #'> counts)) counts scales));;;;;#|(find-the-best           7           '(7 4 5 5 2 6 6 1 5 3 3 3 4 7 6 4)           '(((2 2 1 2 2 2) major) ((2 1 2 2 1 2) nat-minor)...)   (major polytonal)|#;;;;;(defun FIND-THE-BEST (best counts scales)  "Returns the type and scale in a list."  (cond ((null counts)())        ((eq best (first counts))         (cons (second (first scales))               (find-the-best best (cdr counts)(cdr scales))))        (t (find-the-best best (cdr counts)(cdr scales)))));;;;;#|(define-the-proper-intervals '(6 7 8))(1 1)|#;;;;;(defun DEFINE-THE-PROPER-INTERVALS (pcs)  "This function redefines the interval list that does not begin on 0."  (if (null (zerop (first pcs)))    (make-intervals (add-the-12s pcs))    (make-intervals pcs)));;;;;#|(add-the-12s '(67 69 71 60 62 64 66))    (67 69 71 72 74 76 78)|#;;;;;(defun ADD-THE-12S (pcs &optional (last 0))  "Helps form a continuous upward scale."  (cond ((null pcs)())        ((< (first pcs) last)         (cons (+ (first pcs) 12)               (add-the-12s (cdr pcs)(+ (first pcs) 12))))        (t (cons (first pcs)                 (add-the-12s (cdr pcs)(first pcs))))));;;;;#|(remove-below-the-line           '((67 102) (69 37) (71 46) (60 55) (62 55) (64 37) (66 28)))     ((67 102) (69 37) (71 46) (60 55) (62 55)     (64 37) (66 28))|#;;;;;(defun REMOVE-BELOW-THE-LINE (notes-and-ratings)  "Removes those below the average."  (remove-below notes-and-ratings                (round (/ (apply #'+ (mapcar #'second notes-and-ratings))                          (* 3 (length notes-and-ratings))))));;;;;#|(remove-below '((67 102) (69 37) (71 46) (60 55) (62 55) (64 37)                        (66 28))                       17)     ((67 102) (69 37) (71 46) (60 55) (62 55) (64 37)     (66 28))|#;;;;;(defun REMOVE-BELOW (notes-and-ratings threshold)  "Removes those below the threshold."  (cond ((null notes-and-ratings)())        ((< (second (first notes-and-ratings)) threshold)         (remove-below (cdr notes-and-ratings) threshold))        (t (cons (first notes-and-ratings)                 (remove-below (cdr notes-and-ratings) threshold)))));;;;;#|(remove-special-forms           nil           '(((2 2 1 2 2 2) major) ((2 1 2 2 1 2) nat-minor)             ((2 1 2 2 1 3) harm-minor)...)     (((2 2 1 2 2 2) major) ((2 1 2 2 1 2) nat-minor)     ((2 1 2 2 1 3) harm-minor)...|#;;;;;(defun REMOVE-SPECIAL-FORMS (intervals scales)  "Removes special scales."  (cond ((null scales)())        ((and (not (equal (length intervals)                          (1- (length (very-first scales)))))              (member '* (very-first scales)))         (remove-special-forms intervals (cdr scales)))        (t (cons (first scales)                 (remove-special-forms intervals (cdr scales))))));;;;;#|(get-active-channels           '((0 60 1000 4 127) (0 67 1000 2 127) (0 64 1000 3 127)            (0 72 1000 1 127) (1000 55 1000 4 127) (1000 67 1000 2 127)...    (1 2 3 4)|#;;;;;(defun GET-ACTIVE-CHANNELS (music &optional (channel 1))  "Returns all of the channels being used by music arg."  (cond ((> channel 16)())        ((get-channel channel music)         (cons channel (get-active-channels music (1+ channel))))        (t (get-active-channels music (1+ channel)))));;;;;#|(get-dynamic 64)   cmn::mp|#;;;;;(defun GET-DYNAMIC (n)  "Gets the dynamic of the number for notation display."  (cond ((< n 27) 'cmn::pp)        ((< n 47) 'cmn::p)        ((< n 67) 'cmn::mp)        ((< n 77) 'cmn::mf)        ((< n 97) 'cmn::f)        (t 'cmn::ff)));;;;;#|(thousandp 1223)     nil  (thousandp 4000)     t|#;;;;;(defun THOUSANDP (number)  "Calling "  (if (zerop (mod number 1000)) t));;;;;#|(remove-rests ((0 51 1000 1 127) (0 59 1000 2 127) (0 69 1000 3 127) (1000 49 1000 1 127)....     ((0 51 1000 1 127) (0 59 1000 2 127) (0 69 1000 3 127) (1000 49 1000 1 127)      (1000 56 1000 2 127) (1000 65 1000 3 127) (2000 51 1000 1 127)....|#;;;;;(defun REMOVE-RESTS (events)  "Removes rests from midi files."  (loop for event in events        if (null (zerop (second event)))        collect event));;;;;#|(evaluate-channels '((0 51 1000 1 127) (0 59 1000 2 127) (0 69 1000 3 127) (1000 49 1000 1 127)                        (1000 56 1000 2 127) (1000 65 1000 3 127) (2000 51 1000 1 127)))((0 51 1000 1 127) (0 59 1000 2 127) (0 69 1000 3 127) (1000 49 1000 1 127) (1000 56 1000 2 127) (1000 65 1000 3 127) (2000 51 1000 1 127))|#;;;;;(defun EVALUATE-CHANNELS (events)  "Allows for channel over rides during playing."  (loop for event in events        collect (append (firstn 3 event)                        (list (eval (concat '*channel- (fourth event) '*)))                        (last event))));;;;;#|(get-channel 2 '((0 51 1000 1 127) (0 59 1000 2 127) (0 69 1000 3 127) (1000 49 1000 1 127)                        (1000 56 1000 2 127) (1000 65 1000 3 127) (2000 51 1000 1 127)))((0 59 1000 2 127) (1000 56 1000 2 127))|#;;;;;(defun GET-CHANNEL (n music)  "Gets the nth channel of the music."  (cond ((null music)())        ((equal (fourth (first music)) n)         (cons (first music)(get-channel n (cdr music))))        (t (get-channel n (cdr music)))));;;;;#|(get-duration '(0 60 1000 1 127))       1000|#;;;;;(defun GET-DURATION (event)  "Returns duration from event."  (third event));;;;;#|(create-slice-of-pie           120/13           '((c 6) (d 6) (e 4) (gb 3) (g 11) (a 4) (b 5)))       ((c 55) (d 55) (e 37) (gb 28) (g 102) (a 37)(b 46))|#;;;;;(defun CREATE-SLICE-OF-PIE (total-number-div-into-360 collected-note-list &optional (total 0))  "Creates the weights of scale degrees."  (if (null collected-note-list)()      (let ((test (round (* total-number-div-into-360                             (second  (first collected-note-list))))))        (cons (list (first (first collected-note-list))                    (if (null (cdr collected-note-list))                      (- 360 total) test))              (create-slice-of-pie total-number-div-into-360 (cdr collected-note-list)                                   (+ test total))))))